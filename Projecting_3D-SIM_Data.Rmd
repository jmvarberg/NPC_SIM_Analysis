---
title: "Projecting 3D-SIM Data"
author: "JM Varberg"
date: "3/29/2022"
output: 
  html_document:
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, error=FALSE)
```

```{r}
library(rgl)
library(bio3d)
library(geometry)
library(tidyverse)
library(ggplot2)
library(cowplot)
library(summarytools)
library(data.table)
```


## Objective
We are interested in looking at the distribution of NPCs/points on the surface of a sphere. However, the nuclei we are imaging are not perfectly spherical, making it difficult to analyze and compare statistically with simulated data on spherical surfaces. Here, we will try to project the NPC points onto a unit sphere based on the average distance from each point to the centroid of the point cloud. Then, we can look at the distribution of distances between the points by computing the lengths of the vertices of the triangles generated by computing the convex hull.

### Raw data

```{r}
nuc <- fread("./data/Cdc25_22_Nup37-mCherry_Asynchronous_good_02_visit_1_SIR_nuc0.xls", select = c("x", "y", "z"))

nuc <- nuc %>% 
  mutate(x=x*0.040,
         y=y*0.040,
         z=z*0.125)

NPC.plot <- function(sim, alpha = 0.4, main=NULL, ...) {
    sim <- as.data.frame(sim)
    x <- sim$x
    y <- sim$y
    z <- sim$z
    plot3d(x, y, z, col="blue", box = FALSE,
           type ="p", size = 5, aspect = "iso", axes = FALSE, main=main)
    ts.surf1 <- t(convhulln(sim))  # see the qhull documentations for the options
    convex1 <-  rgl.triangles(sim[ts.surf1,1],sim[ts.surf1,2],sim[ts.surf1,3],col="gold2",alpha= alpha)
}

NPC.plot(nuc)
rglwidget()
```

### Convex hull optimization by removing outliers

Next, we remove outliers by optimizing the fraction of points on the surface of the convex hull.

```{r}
##define the function hullopt for hull optimization
hullopt <- function(data) {
    input <- data
    centroid <- data %>% 
      summarise_all(mean)
    #print(centroid)
    input$dist2cent <- as.numeric(dist.xyz(as.matrix(input), as.matrix(centroid))) #dist.xyz has to have matrices as input
    input <- input %>% arrange(desc(dist2cent))
    rows <- nrow(input)
    loop <- 1
    
    while (0.1*rows > loop) {
        i <- loop+1
        current <- input[loop:rows, ]
        currenthull <- convhulln(current[,1:3])
        currentrows <- nrow(current)
        currentpct <- length(unique(c(currenthull)))/currentrows
        test <- input[i:rows, ]
        testhull <- convhulln(test[,1:3])
        testrows <- nrow(test)
        testpct <- length(unique(c(testhull)))/testrows
        loop <- loop + 1
        if(testpct < currentpct) {
            loop <- loop-1
            break
        }
    }
    
    output <- input[loop:rows, 1:3]
    optinfo <- loop-1
    return(list("info" = optinfo, "output" = output))
    
}

## try the optimization and visualize output. The hullopt function output is a list, with the first object containing info on how many points were removed, and the second object being the filtered x/y/z coordinate dataset.
rgl.close()
nucopt <- hullopt(nuc)
print(paste("Number of points removed: ", nucopt$info))

mfrow3d(nr=1, nc=2, sharedMouse=TRUE)
NPC.plot(nuc, main="Unfiltered Points")
NPC.plot(nucopt$output, main="Filtered Points")
rglwidget()
```

Now, using the optimized point cloud, objective is to project these points to the surface of a sphere. First, letâ€™s look at an example using simulated points on a sphere surface. Since all points are on the convexhull surface, we can measure the vertices and plot distributions between NPCs along the NE surface.

```{r}
## generate random points on sphere with icosa::rpsphere

simulated <- data.frame(icosa::rpsphere(130, radius=1230))
rgl.close()
NPC.plot(simulated, main="Simulated random 130 points on sphere")
rglwidget()
```

```{r}
#convex hull of points generates output of matrix where each row is three points that comprise triangles that make up convex hull
chullsim <- convhulln(simulated)

#function to calculate euclidean distance between two x/y/z points
dist3d <- function(p1, p2) {
  dist <- sqrt((p2[,1]-p1[,1])^2 + (p2[,2]-p1[,2])^2 + (p2[,3]-p1[,3])^2)
  return(dist)
}

#function to go through rows of convexhull matrix, pull each point, then calculate distances between each pair of points in each triangle
vertexDists <- function(points, hull) {
  # hull <- as.data.frame(t(hull))
  # points <- as.data.frame(points)
  
  out1 <- list()
  out2 <- list()
  out3 <- list()
  for(i in 1:nrow(hull)) {
    r1 <- hull[i, 1]
    r2 <- hull[i, 2]
    r3 <- hull[i, 3]
    
    p1 <- points[r1, ]
    p2 <- points[r2, ]
    p3 <- points[r3, ]
    
    d1 <- dist3d(p1, p2)
    d2 <- dist3d(p1, p3)
    d3 <- dist3d(p2, p3)
    
    out1[[i]] <- d1
    out2[[i]] <- d2
    out3[[i]] <- d3
    
  }
  output <- mapply(c, out1, out2, out3, SIMPLIFY=F)
  output <- as.data.frame(unlist(output))
  colnames(output) <- c("Distance")
  return(output)
}

test <- vertexDists(simulated, chullsim)

p1 <- ggplot(test, aes(x=Distance)) + 
  geom_histogram(aes(y=..density..), colour="black", fill="white", binwidth=50) +
  geom_density(alpha=.2, fill="#FF6666") + 
  ggtitle("Simulated Random ") +
  xlab("Distance (nm)") +
  ylab("Density") +
  theme_cowplot()
p1
```

The problem is that only a fraction of the points in the real datasets are on the hull surface (because the nuclear envelope has a combination of convex and concave surfaces, but convex hull cannot handle concave surfaces).

```{r}
NPC.plot(nucopt$output, main="Filtered Points")
rglwidget()
```

```{r}
##calculate fraction of points on convex hull surface in original dataset
nuchull <- convhulln(nucopt$output) #output is a matrix with the numbers of the points that comprise the vertices of each trinangle of the convex hull surface
ptsnuc <- unique(c(nuchull)) #extracts unique values from convhulln matrix
print(paste("Fraction of points on hull surface,: ", round(length(ptsnuc)/nrow(nuc), digits=3)))
```

## Projecting 3D-SIM data onto sphere surface

So, the objective is to project the points from the real dataset onto a spherical surface. The approach is as follows:

* Calculate the centroid of the original point cloud and set to (0,0,0)
* Convert the original point coordinates to be relative to the centroid at (0,0,0) by subtracting centroid x/y/z from data x/y/z
* Compute the distance for each point to the centroid and take the mean to determine the radius of the sphere to be projected to
* Compute the direction cosines in each axis using equation cosx = x/vector length (etc. for y and z)
* Derive the new xyz coordinates by multiplying the direction cosines by the desired sphere radius

```{r}
#first, compute the centroid and then will set that to (0,0,0)
centroid <- nucopt$output %>% 
  summarise_all(mean)

#subtract centroid coords from each point in dataset
normnuc <- nucopt$output %>% 
  mutate(x = x-centroid$x,
         y = y-centroid$y,
         z = z-centroid$z)

#3D plot to make sure transformation looks correct
#rgl.close()
# NPC.plot(normnuc, main="Centroid normalized")
# rglwidget()

#set centroid to (0,0,0)
centroidnorm <- centroid - centroid

#calculate distance to centroid for each point using dist.xyz function from bio3d
normnuc$dist2cent <- as.numeric(dist.xyz(as.matrix(normnuc), as.matrix(centroidnorm))) #dist.xyz has to have matrices as input
print(paste("Average distance to centroid: ", round(mean(normnuc$dist2cent), digits=2)))
```

```{r}
#scale the vector to have length equal to radius of the sphere, which is the average distance to centroid
normnuc <- normnuc %>% 
  mutate(cosx = x/dist2cent,
         cosy = y/dist2cent,
         cosz = z/dist2cent)

projnuc <- normnuc %>% 
  mutate(X = cosx*mean(dist2cent),
         Y = cosy*mean(dist2cent),
         Z = cosz*mean(dist2cent)) %>% 
  select(X, Y, Z)
colnames(projnuc) <- c("x", "y", "z")

#plot the raw and projected data side by side
rgl.close()

raw <- normnuc %>% 
  select(x,y,z)

mfrow3d(nr=1, nc=2, sharedMouse=TRUE)
NPC.plot(raw, main="Raw Data")
NPC.plot(projnuc, main="Projected Data")
rglwidget()
```

```{r}
#look at points on surface for each

nuchull <- convhulln(nucopt$output) #output is a matrix with the numbers of the points that comprise the vertices of each trinangle of the convex hull surface
ptsnuc <- unique(c(nuchull)) #extracts unique values from convhulln matrix
print(paste("Fraction of points on hull surface,: ", round(length(ptsnuc)/nrow(nuc), digits=3)))##calculate fraction of points on convex hull surface in original dataset
```

```{r}
projhull <- convhulln(projnuc) #output is a matrix with the numbers of the points that comprise the vertices of each trinangle of the convex hull surface
ptsproj <- unique(c(projhull)) #extracts unique values from convhulln matrix
print(paste("Fraction of points on projected hull surface,: ", round(length(ptsproj)/nrow(projnuc), digits=3)))
```

We can see that now the points have all been put onto the surface of a sphere, and all points are present on the convex hull. Now we can actually measure all NPC:NPC distances by extracting the length of the vertices of the triangles that make the convex hull. We compare the vertex distances between the projected real data set and a simulated dataset of the same NPC density for randomly-placed points.

```{r}
#Function to calcualte an object's sphericity from user-defined volume and surface area values
sphericity <- function(volume, area) {
  (pi^(1/3) * (6*volume)^(2/3))/area
}

##Custom function to extract surface area from 3D convexhull with error handling. 
surf.area <- function(x, cond="problem") {
  out <- tryCatch(
    {
      convhulln(x, options="FA")$area
    }, error = function(cond) {
      message("Error with convex hull computation")
      return(NA)
    }, warning = function(cond) {
      message("Warning during convex hull computation")
      return(NA)
    }
  )
  return(out)
}

##Custom function to extract volume from 3D convexhull with error handling. 
volume <- function(x, cond="problem") {
  out <- tryCatch(
    {
      convhulln(x, options="FA")$vol
    }, error = function(cond) {
      message("Error with convex hull computation")
      return(NA)
    }, warning = function(cond) {
      message("Warning during convex hull computation")
      return(NA)
    }
  )
  return(out)
}

#Function to calculate surface area, volume, sphericity and number of NPCs for dataframe of x/y/z NPC coordinates.
NPC.stats <-function(x) {
  num.NPCs <- nrow(x)
  SA <- surf.area(x)
  VOL <- volume(x)
  sphericity.x <- sphericity(VOL, SA)
  density <- num.NPCs/SA
  data.frame(SA, VOL, sphericity.x, num.NPCs, density)
}

simstats <- round(NPC.stats(simulated/1000), digits=2)
colnames(simstats) <- c("Surface_Area", "Volume", "Sphericity", "Number_NPCs", "NPC_Density")
knitr::kable(simstats, caption="Simulated Random Data")

nucstats <- round(NPC.stats(projnuc), digits=2)
colnames(nucstats) <- c("Surface_Area", "Volume", "Sphericity", "Number_NPCs", "NPC_Density")
knitr::kable(nucstats, caption="Projected Dataset")
```

```{r}
#plot distribution of vertex distances for projected data set
projvert <- vertexDists(projnuc, projhull)

p2 <- ggplot(projvert, aes(x=Distance*1000)) + 
  geom_histogram(aes(y=..density..), colour="black", fill="white", binwidth=50) +
  geom_density(alpha=.2, fill="#FF6666") + 
  ggtitle("Projected") +
  xlab("Distance (nm)") +
  ylab("Density") +
  theme_cowplot()

plot_grid(p1, p2, nrow=1, ncol=2)
```

```{r}
#combine onto one plot simulated and projected real data and compare distributions

test$group <- c("Simulated")
projvert$group <- c("Projected")
projvert$Distance <- projvert$Distance*1000

combdf <- rbind(test,projvert)

#make raincloud plot comparing distributions of these two with statistics
library(install.load)
install_load("ggplot2", "data.table", "MASS", "viridis", "knitr", "cowplot", "kableExtra", "ggforce", "Hmisc", "ggpubr", "tidyverse", "broom","ggpmisc", "see")

#custom functions for calculating upper and lower bounds for error bars
lb <- function(x) mean(x) - sd(x)
ub <- function(x) mean(x) + sd(x)

#calculate summary stats by category
sum <- combdf %>% 
  group_by(group) %>% 
  summarise_if(is.numeric, list(mean=mean, median=median, lower=lb, upper=ub))

g <- ggplot(data = combdf, aes(y = Distance, x = group, fill = group, color=group)) +
  see::geom_violinhalf(position = position_nudge(x = .2, y = 0), alpha = .8) +
  geom_point(aes(y = Distance, color = group), position = position_jitter(width = .15), size = .5, alpha = 0.8) +
  geom_point(data = sum, aes(x = group, y = mean), position = position_nudge(x = 0.3), size = 2.5, color="black") +
  geom_errorbar(data = sum, aes(ymin = lower, ymax = upper, y = mean), position = position_nudge(x = 0.3), width = 0, color="black") +
  expand_limits(x = 3) +
  stat_compare_means(method = "wilcox.test", paired = FALSE, label.y = 50, label.x=2.75, size=4) +
  xlab("") +
  ylab("NPC:NPC Distances (nm)")+
  #ylim(0,0.8)+
  guides(fill = FALSE) +
  guides(color = FALSE) +
  #scale_color_brewer(palette = "Spectral") +
  #scale_fill_brewer(palette = "Spectral") +
  coord_flip() +
  theme_cowplot() +
  theme(aspect.ratio=0.75)
g
```

This works nicely. Next step is to apply to full dataset and make distributions from multiple images/nuclei, then ideally want to compare the distributions to those of simulated datasets with same distribution of densities